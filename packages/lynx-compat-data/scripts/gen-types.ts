/* This file is a part of lynx-compat-data
 * See LICENSE file for more information. */

/**
 * This script is used to generate the types.d.ts file.
 * It uses json-schema-to-typescript to compile types from the schemas/*.schema.json files.
 */

/* c8 ignore start */

import { execSync } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import esMain from 'es-main';
import { fdir } from 'fdir';
import { compileFromFile } from 'json-schema-to-typescript';

import extend from './lib/extend.js';

const dirname = fileURLToPath(new URL('.', import.meta.url));

const opts = {
  bannerComment: '',
  unreachableDefinitions: true,
};

const header =
  '/* This file is a part of lynx-compat-data\n * See LICENSE file for more information. */\n\n/**\n* This file was automatically generated by json-schema-to-typescript.\n* DO NOT MODIFY IT BY HAND. Instead, modify the source schema files in\n* schemas/*, and run "npm run gentypes" to regenerate this file.\n*/';

/**
 * Generate the platform names TypeScript
 * @returns The stringified TypeScript typedef
 */
const generatePlatformNames = async () => {
  // Load platform data independently of index.ts, since index.ts depends
  // on the output of this script
  const platformData: { platforms: Record<string, unknown> } = {
    platforms: {},
  };

  const paths = new fdir()
    .withBasePath()
    .filter((fp) => fp.endsWith('.json'))
    .crawl(path.join(dirname, '..', 'platforms'))
    .sync() as string[];

  for (const fp of paths) {
    try {
      const contents = await fs.readFile(fp);
      extend(platformData, JSON.parse(contents.toString('utf8')));
    } catch (e) {
      // Skip invalid JSON. Tests will flag the problem separately.
      continue;
    }
  }

  // Generate PlatformName type
  const platforms = Object.keys(platformData.platforms);
  return `/**\n * The names of the known platforms.\n */\nexport type PlatformName = ${platforms
    .map((p) => `"${p}"`)
    .join(' | ')};`;
};

/**
 * Transform the TypeScript to remove unneeded bits of typedefs
 * @param platformTS Typedefs for PlatformName
 * @param compatTS Typedefs for CompatData
 * @returns Updated typedefs
 */
const transformTS = (platformTS: string, compatTS: string): string => {
  let ts = `${platformTS}\n\n${compatTS}`;

  ts = ts
    .replace(
      'export interface PlatformDataFile {\n  platforms?: Platforms;\n}',
      '',
    )
    .replace('export interface CompatDataFile {}', '')
    .replace(
      /\/\*\*\n \* This interface was referenced by `CompatDataFile`'s JSON-Schema\n \* via the `definition` "spec_url_value"\.\n \*\/\nexport type SpecUrlValue = string;\n/,
      '',
    )
    .replace(
      /\/\*\*\n \* This interface was referenced by `CompatDataFile`'s JSON-Schema\n \* via the `definition` "impl_url_value"\.\n \*\/\nexport type ImplUrlValue = string;\n/,
      '',
    )
    .replace(
      '/**\n * This interface was referenced by `CompatDataFile`\'s JSON-Schema\n * via the `definition` "support_block".\n */\nexport type SupportBlock1 = Partial<Record<PlatformName, SupportStatement>>;\n',
      '',
    )
    .replace(
      /\/\*\*\n \* This interface was referenced by `CompatDataFile`'s JSON-Schema\n \* via the `definition` "status_block"\.\n \*\/\nexport interface StatusBlock1 {(.*\n)*}\n/,
      '',
    );

  return ts;
};

/**
 * Compile the TypeScript typedefs from the schema JSON
 * @param destination Output destination
 */
const compile = async (
  destination: URL | string = new URL('../types/types.d.ts', import.meta.url),
) => {
  const platformTS = await compileFromFile(
    'schemas/platform.schema.json',
    opts,
  );
  const compatTS = await compileFromFile(
    'schemas/compat-data.schema.json',
    opts,
  );

  const ts = [
    header,
    await generatePlatformNames(),
    'export type VersionValue = string | boolean | null;',
    transformTS(platformTS, compatTS),
  ].join('\n\n');
  await fs.writeFile(destination, ts);
  execSync('tsc ../types/types.d.ts', { cwd: dirname, stdio: 'inherit' });
};

if (esMain(import.meta)) {
  await compile();
}

export default compile;

/* c8 ignore stop */
